// Generated by CoffeeScript 1.12.7
var Buffer, PassThrough, Stream, When, bindCallback, nodefn, rawBody, ref, streamToBuffer;

rawBody = require('raw-body');

When = require('when');

nodefn = (function() {
  try {
    return require('when/node');
  } catch (error) {
    return require('when/node/function');
  }
})();

Buffer = require('buffer').Buffer;

ref = require('stream'), Stream = ref.Stream, PassThrough = ref.PassThrough;

streamToBuffer = nodefn.lift(rawBody);

PassThrough || (PassThrough = require('through'));

bindCallback = function(promise, next) {
  if (typeof next === 'function') {
    return nodefn.bindCallback(promise, next);
  } else {
    return promise;
  }
};

module.exports = {
  _write: function(source, outname) {
    var args, res, stdin, stdout;
    outname || (outname = '-');
    stdin = typeof source !== 'string';
    stdout = outname === '-';
    args = [].concat(this.args(), ['-o', outname, '--', (stdin ? '-' : source)]);
    if (!stdin) {
      return this._spawn(args, stdin, stdout);
    } else if (Buffer.isBuffer(source)) {
      res = this._spawn(args, stdin, stdout);
      res.stdin.end(source);
      return res;
    } else if (source instanceof Stream) {
      res = this._spawn(args, stdin, stdout);
      source.pipe(res.stdin);
      return res;
    } else {
      return {
        promise: When.reject(new Error('Mailformed source'))
      };
    }
  },
  write: function(outname, next) {
    var promise;
    promise = outname ? (this._write(this.source, outname)).promise : When.reject(new Error('outname in not specified'));
    return bindCallback(promise, next);
  },
  toBuffer: function(next) {
    return bindCallback(streamToBuffer(this.stream()), next);
  },
  stream: function() {
    var outstream, promise, res;
    outstream = new PassThrough();
    res = this._write(this.source, '-');
    promise = res.stdout ? (res.stdout.pipe(outstream, {
      end: false
    }), res.promise) : res.promise.then(function() {
      return When.reject(new Error('Failed to pipe stdout'));
    });
    promise.then(function() {
      return outstream.end();
    }).otherwise(function(err) {
      return outstream.emit('error', err);
    });
    return outstream;
  }
};
